#include <iostream>
#include <vector>
#include <cassert>
#include <bitset>
#include <cmath>

using namespace std;

#define trace(x)  cout << #x << " = " << x << endl
#define btrace(x) cout << #x << " = " << bitset<12>(x) << endl


int n,k;
vector<int> s;

int f(int m_out, int size_out, int m_red,int size_red, int goal){
  if(size_red == 0 && goal == 0) return 1;
  if(size_red == 0 && goal != 0) return 0;
  if(size_red == 1){
    int sol = 0;
    int i=0;
    while(! (m_red & (1<<i))){
      ++i;
    }
    if(s[i] == goal) ++sol;
    if(goal == 0 && s[i]==0) ++sol;
    return sol;
  }

  int sol = 0;

  // try with all of them 
  int sum = 0;
  for(int i=0;i<n;i++){
    if( m_red & (1<<i)) sum += s[i];
  }
  if(sum == goal) ++sol;

  // or without one
  for(int i=0;i<n;++i){
    if(m_red & (1<<i)){
      int res = f(m_out, size_out, m_red & (~(1<<i)), size_red-1, goal-s[i]);
      sol += res;
    }
  }
  return sol;
}

void testcase(){
  cin >> n >> k;
  s.clear();
  s.resize(n);
  for(int i=0;i<n;i++){
    cin >> s[i];
  }

  int sol=0;
  for(int m_out=0;m_out< 1<<n;++m_out){ // all subsets for K
    int sk = 0;
    for(int j=0; j<n;++j){
      if(m_out & (1<<j)) ++sk;
    }
    if(sk>k) continue;

    int goal=0;
    for(int j=0;j<n;++j){
      if(! (m_out & (1<<j))) goal += s[j];
    }
    if(goal %2 == 1) continue; //if odd it is not possible to divide in two
    goal = goal / 2;
    
    int result = f(m_out, sk, (~m_out) & ( (int) pow(2,n)-1), n-sk,goal);
    trace("===");
    btrace(m_out);
    trace(sk);
    trace(goal);
    trace(result);
    sol += result;
    
  }
  cout << sol << endl;
}

int main(){
  ios_base::sync_with_stdio(false);

  /*
  vector<vector<int>> maps(4,vector<int>(10));
  fill_gen_maps(10,3,maps);

  for(vector<int> mm : maps){
    for(int x : mm){
      btrace(x);
    }
  }
  */

  int T; cin >> T;
  while(T--) testcase();
}
